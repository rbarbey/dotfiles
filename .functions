#!/bin/bash

# Find stuff in Maven POM files within this directory
findpom() {
    rg "$@" --glob "pom.xml" --glob "!**/target/**"
}

# Generate a random string which can serve as the basis for a password
genpasswd() {
  cat /dev/urandom | head -c 100 | base64 | cut -c -${1:-12}
}

# Determine disk usage for all files, also dotdirs
dusch() {
  local full_output=false
  local num_lines=""

  # Parse command line arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -f)
        full_output=true
        shift
        ;;
      -n)
        num_lines="$2"
        shift 2
        ;;
      *)
        echo "Usage: dusch [-f] [-n NUM]"
        echo "  -f      Show full output (no truncation)"
        echo "  -n NUM  Show only NUM lines"
        return 1
        ;;
    esac
  done

  # Build the command
  local cmd="du -sch .[!.]* * | sort -rh"

  if [[ "$full_output" == true ]]; then
    # Don't truncate
    eval "$cmd"
  elif [[ -n "$num_lines" ]]; then
    # Use specific number of lines
    eval "$cmd | head -n $num_lines"
  else
    # Default behavior (current behavior)
    eval "$cmd | head"
  fi
}

# Start an HTTP server from a directory, optionally specifying the port
server() {
    python3 -m http.server
}

eclipse() {
  open -n /Applications/Eclipse.app
}

# Decode Header and Payload of a JWT
jwt() {
    if [[ -x $(command -v jq) ]]; then
        jq -R 'split (".") | .[0],.[1] | @base64d | fromjson' <<< "${1}"
        echo "Signature: $(echo "${1}" | awk -F'.' '{print $3}')"
    fi
}

# Pad string from stdin so that it can be base64 decoded
pad () {
    while read str; do
        while [ $((${#str} % 4)) -ne 0 ]; do
            str+="="
        done
        printf "$str"
    done
}

parseJwtPart() {
    echo "$1" | cut -d '.' -f "$2" | pad | base64 -D | jq -C
}


mcd() {
  mkdir -p "$1"; cd "$1";
}

rurl() {
    # follow redirect but print what's going on
    # redirect stderr to be able to grep curl output
    (set -o pipefail && curl -L "$1" 2>&1 | egrep "^[<>] (Location:|Host:|GET)")
}

remacs() {
    local has_emacsclient=0
    if pgrep -x emacsclient >/dev/null 2>&1; then
        has_emacsclient=1
    fi

    # Stop the daemon if it exists.
    echo "Killing current Emacs daemon"
    emacsclient -e "(kill-emacs)" >/dev/null 2>&1 || true

    # Start a fresh daemon and wait until it's responsive.
    echo "Starting new Emacs daemon"
    emacs --daemon >/dev/null 2>&1


    # If we didn't have any emacsclient process before, open one now (if available).
    if [[ $has_emacsclient -eq 1 ]]; then
        echo "Starting Emacs client"
        em >/dev/null 2>&1
    fi
}
